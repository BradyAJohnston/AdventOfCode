[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AdventOfCode",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "2024/index.html",
    "href": "2024/index.html",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "# Read the file into an array of lines\nlines = readlines(\"data/day_1.txt\")\nsplit_lines = [parse.(Int, split(line)) for line in lines]\n\ncol1 = [x[1] for x in split_lines]\ncol2 = [x[2] for x in split_lines]\n\nsort!(col1)\nsort!(col2)\n\ntotal = 0\nfor i in 1:length(col1)\n    total += abs(col1[i] - col2[i])\nend\n\nprint(\"Total distance of all coordinates: \" * string(total))\n\nTotal distance of all coordinates: 1830467"
  },
  {
    "objectID": "2024/index.html#day-1",
    "href": "2024/index.html#day-1",
    "title": "Advent of Code 2024",
    "section": "",
    "text": "# Read the file into an array of lines\nlines = readlines(\"data/day_1.txt\")\nsplit_lines = [parse.(Int, split(line)) for line in lines]\n\ncol1 = [x[1] for x in split_lines]\ncol2 = [x[2] for x in split_lines]\n\nsort!(col1)\nsort!(col2)\n\ntotal = 0\nfor i in 1:length(col1)\n    total += abs(col1[i] - col2[i])\nend\n\nprint(\"Total distance of all coordinates: \" * string(total))\n\nTotal distance of all coordinates: 1830467"
  },
  {
    "objectID": "2024/index.html#day-2",
    "href": "2024/index.html#day-2",
    "title": "Advent of Code 2024",
    "section": "Day 2",
    "text": "Day 2\n\n\nfunction check_report_safe(report::Vector{Int})\n    change = diff(report)\n    is_size_safe = Base.between.(abs.(change), 1, 3)\n    is_dir_safe = diff(sign.(change)) .== 0\n    return all(is_dir_safe) & all(is_size_safe)\nend\n\nexamples = [\n    [7, 6, 4, 2, 1], \n    [1, 2, 7, 8, 9], \n    [9, 7, 6, 2, 1], \n    [1, 3, 2, 4, 5], \n    [8, 6, 4, 4, 1], \n    [1, 3, 6, 7, 9]\n]\n\nanswers = [true, false, false, false, false, true]\n\n\n@assert check_report_safe.(examples) == answers\n\n\nlines = readlines(\"data/day_2.txt\")\nsplit_lines = [parse.(Int, split(line)) for line in lines]\n\nis_report_safe = check_report_safe.(split_lines)\nn_safe = sum(is_report_safe)\n\nprint(\"Total safe reports: $n_safe\")\n\n\nTotal safe reports: 369"
  },
  {
    "objectID": "2024/index.html#day-3",
    "href": "2024/index.html#day-3",
    "title": "Advent of Code 2024",
    "section": "Day 3",
    "text": "Day 3\nHaving spent a bunch of time learning regex a couple of years ago continues to always payoff, being able to just pattern match without having to look up what to use is always great.\n\nPart 1\n\n\nexample = \"xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))\"\nexample_numbers = [8, 25, 88, 40]\n\n\nfunction mulstring_to_int(mulstring)\n    return prod([parse(Int, x.match) for x in eachmatch(r\"\\d+\", mulstring)])\nend\n\nfunction extract_mulstrings(line)\n    return [m.match for m in eachmatch(r\"mul\\(\\d+,\\d+\\)\", line)]\nend\n\n@assert mulstring_to_int(\"mul(11,8)\") == 88\n@assert mulstring_to_int(\"mul(8,5)\") == 40\n\nexample_parsed = mulstring_to_int.(extract_mulstrings(example))\n@assert example_parsed == example_numbers\n\n\nlines = readlines(\"data/day_3.txt\")\nextracted_values = [mulstring_to_int.(x) for x in extract_mulstrings.(lines)]\n\ntotal = sum(sum.(extracted_values))\n\nprint(\"Total sum of all mul calls: $total\")\n\nTotal sum of all mul calls: 185797128\n\n\n\n\nPart 2\nThis uses global values, which I’m not a fan of, but I couldn’t be bothered remaking it to work better with the global context\n\nexample = \"xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))\"\nexample_numbers = [8, 40]\n\nglobal is_enabled = true\n\nfunction extract_conditional_mulstrings(string)\n    global is_enabled\n    matches = [m.match for m in eachmatch(r\"(mul\\(\\d+,\\d+\\)|don't\\(\\)|do\\(\\))\", string)]\n    enabled_matches = String[]\n    for match in matches\n        if match == \"don't()\"\n            is_enabled = false\n            continue\n        end\n        if match == \"do()\"\n            is_enabled = true\n            continue\n        end\n        if !is_enabled\n            continue\n        end\n        push!(enabled_matches, match)\n    end\n    enabled_matches\nend\n\n@assert mulstring_to_int.(extract_conditional_mulstrings(example)) == example_numbers\n\nlines = readlines(\"data/day_3.txt\")\nextracted_values = [mulstring_to_int.(x) for x in extract_conditional_mulstrings.(lines)]\n\ntotal = sum(sum.(extracted_values))\n\nprint(\"Total sum of all mul calls: $total\")\n\nTotal sum of all mul calls: 89798695"
  },
  {
    "objectID": "2024/index.html#day-4",
    "href": "2024/index.html#day-4",
    "title": "Advent of Code 2024",
    "section": "Day 4",
    "text": "Day 4\n\nPart 1\nGosh this one got really messy really quickly. Had to use copilot to help me write the diagnoal finder, not enough coffee to figure that out out myself.\nProbably a bad approach to it, but it works!\n\nexample = \"MMMSXXMASM\nMSAMXMSMSA\nAMXSXMAAMM\nMSAMASMSMX\nXMASAMXAMM\nXXAMMXXAMA\nSMSMSASXSS\nSAXAMASAAA\nMAMMMXMMMM\nMXMXAXMASX\"\n\nexample_matched = \"....XXMAS.\n.SAMXMS...\n...S..A...\n..A.A.MS.X\nXMASAMX.MM\nX.....XA.A\nS.S.S.S.SS\n.A.A.A.A.A\n..M.M.M.MM\n.X.X.XMASX\"\n\npatterns = [\"XMAS\", \"SAMX\"]\n\nexample = read(\"data/day_4.txt\", String)\n\nfunction str_as_matrix(str)\n    lines = split(str)\n    n_rows = length(lines)\n    n_cols = length(lines[1])\n    mat = fill('.', n_rows, n_cols)\n    for (i, line) in enumerate(lines)\n        mat[i, :] = collect(line)\n    end\n    mat\nend\n\n\nmat_chr = str_as_matrix(example)\n\nn_rows, n_cols = size(mat_chr)\n\nmat_matched = fill(false, n_rows, n_cols)\n\n\nfunction match_to_mask(match::RegexMatch{String})\n    start_idx = match.offset\n    end_idx = start_idx + length(match.match) - 1\n    empty = fill(false, length(match.match.string))\n    empty[start_idx:end_idx] .= true\n    empty\nend\n\ncounter = 0\n\n\nglobal indexes = reshape(1:(n_cols*n_rows), n_rows, n_cols)\nfor pattern in [r\"XMAS\", r\"SAMX\"]\n\n    for i in 1:n_rows\n        matches = collect(eachmatch(pattern, join(mat_chr[i, :]), overlap=true))\n        if length(matches) == 0\n            continue\n        end\n        for m in matches\n            mat_matched[i, :] = mat_matched[i, :] .| match_to_mask(m)\n            counter += 1\n        end\n    end\n\n    for j in 1:n_cols\n        matches = collect(eachmatch(pattern, join(mat_chr[:, j]), overlap=true))\n        if length(matches) == 0\n            continue\n        end\n        for m in matches\n            mat_matched[:, j] = mat_matched[:, j] .| match_to_mask(m)\n            counter += 1\n\n        end\n    end\n\n\n\n    function get_diagonals(matrix)\n        global indexes\n        n, m = size(matrix)\n        diagonals = Vector[]\n\n        # Get diagonals from top-left to bottom-right\n        for k in 1:(n + m - 1)\n            diag = Int[]\n            for i in 1:n\n                j = k - i + 1\n                if j &gt;= 1 && j &lt;= m\n                    push!(diag, indexes[i, j])\n                end\n            end\n            if !isempty(diag) && length(diag) &gt;= 4\n                push!(diagonals, diag)\n            end\n        end\n\n        # Get diagonals from top-right to bottom-left\n        for k in 1:(n + m - 1)\n            diag = Int[]\n            for i in 1:n\n                j = i + k - n\n                if j &gt;= 1 && j &lt;= m\n                    push!(diag, indexes[i, j])\n                end\n            end\n            if !isempty(diag) && length(diag) &gt;= 4\n                push!(diagonals, diag)\n            end\n        end\n\n        return diagonals\n    end\n\n\n\n\n    diagonals = get_diagonals(mat_chr)\n\n    for diag in diagonals\n        str = join(mat_chr[diag])\n        matches = collect(eachmatch(pattern, str))\n        if length(matches) == 0\n            continue\n        end\n        for match in matches\n            mask = match_to_mask(match)\n            idx = diag[mask]\n            mat_matched[idx] .= true\n            counter += 1\n        end\n    end\nend\n\nmat_matched\nmat_chr_matched = fill('.', n_rows, n_cols)\nmat_chr_matched[mat_matched] .= mat_chr[mat_matched]\nprintln(\"Matches found: $counter\")\n\nMatches found: 2545\n\n\n\n\nPart 2\nOh gosh this is going to get a lot worse.\n\nfunction is_xmas_block(vector)\n    m1 = collect(\"MAS\")\n    m2 = collect(\"SAM\")\n    diag1 = vector[[1, 5, 9]]\n    diag2 = vector[[3, 5, 7]]\n    ((diag1 == m1) | (diag1 == m2)) & ((diag2 == m1) | (diag2 == m2))\nend\n\ncounter = 0\n\nfor row in 1:(n_rows - 2)\n    rows = (1:3) .+ row .- 1\n    for col in 1:(n_cols - 2)\n        cols = (1:3) .+ col .- 1\n        if is_xmas_block(mat_chr[rows, cols])\n            counter += 1\n        end\n    end\nend\n\ncounter\n\n1886\n\n\nActually this was way easier, how very pleasant."
  }
]